<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../style.css" type="text/css" media="screen">
<link rel="stylesheet" href="../print.css" type="text/css" media="print">
<meta content="security,System.security,sandboxType,allowDomain,allowInsecureDomain,loadPolicyFile" name="keywords">
<title>System.security</title>
</head>
<body>
<script type="text/javascript" language="javascript" src="../asdoc.js"></script><script type="text/javascript" language="javascript" src="../cookies.js"></script><script type="text/javascript" language="javascript">
<!--
				asdocTitle = 'security - Flash CS5 ActionScript 2.0 Language Reference';
				var baseRef = '../';
				window.onload = configPage;
			--></script>
<table style="display:none" id="titleTable" cellspacing="0" cellpadding="0" class="titleTable">
<tr>
<td align="left" class="titleTableTitle">Flash CS5 ActionScript 2.0 Language Reference</td><td align="right" class="titleTableTopNav"><a onclick="loadClassListFrame('../all-classes.html')" href="../package-summary.html">All&nbsp;Packages</a>&nbsp;|&nbsp;<a onclick="loadClassListFrame('../all-classes.html')" href="../class-summary.html">All&nbsp;Classes</a>&nbsp;|&nbsp;<a href="../language-elements.html">Language&nbsp;Elements</a>&nbsp;| <a onclick="loadClassListFrame('../index-list.html')" href="../all-index-Symbols.html">Index</a>&nbsp;|&nbsp;<a href="../appendixes.html">Appendixes</a>&nbsp;|&nbsp;<a href="../index.html?System/security.html&amp;System/class-list.html" id="framesLink1">Frames</a><a onclick="parent.location=document.location" href="" style="display:none" id="noFramesLink1">No&nbsp;Frames</a></td><td rowspan="3" align="right" class="titleTableLogo"><img alt="Adobe Logo" title="Adobe Logo" class="logoImage" src="../images/logo.jpg"></td>
</tr>
<tr class="titleTableRow2">
<td align="left" id="subTitle" class="titleTableSubTitle">Class&nbsp;security</td><td align="right" id="subNav" class="titleTableSubNav"><a href="#propertySummary">Properties</a>&nbsp;| <a href="#methodSummary">Methods</a></td>
</tr>
<tr class="titleTableRow3">
<td colspan="2">&nbsp;</td>
</tr>
</table>
<script type="text/javascript" language="javascript">
<!--
if (!isEclipse() || window.name != ECLIPSE_FRAME_NAME) {titleBar_setSubTitle("Class security"); titleBar_setSubNav(false,true,false,false,false,false,true,false,false,false,false,false,false,false);}
--></script>
<div class="MainContent">
<table cellspacing="0" cellpadding="0" class="classHeaderTable">
<tr>
<td class="classHeaderTableLabel">Package</td><td><a onclick="javascript:loadClassListFrame('class-list.html')" href="package-detail.html">System</a></td>
</tr>
<tr>
<td class="classHeaderTableLabel">Class</td><td class="classSignature">public class security</td>
</tr>
<tr>
<td class="classHeaderTableLabel">Inheritance</td><td class="inheritanceList">security <img class="inheritArrow" alt="Inheritance" title="Inheritance" src="../images/inherit-arrow.gif"> <a href="../Object.html">Object</a></td>
</tr>
</table>
<p></p>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" style="white-space:nowrap"><b>Player version:&nbsp;</b></td><td>Flash Player 6</td>
</tr>
</table>
<p></p>
<p></p>The System.security class contains methods that specify how SWF files in different domains can communicate   with each other.         <p>For more information related to security, see the following: </p>            <ul>          <li>"Understanding Security" in <i>Learning ActionScript 2.0 in Flash</i></li>       <li>The Flash Player Developer Center Topic:       <a href="http://www.adobe.com/go/devnet_security_en" target="external">Security</a></li>       </ul>        <p></p>
<br>
<hr>
</div>
<a name="propertySummary"></a>
<div class="summarySection">
<div class="summaryTableTitle">Public Properties</div>
<table id="summaryTableProperty" class="summaryTable " cellpadding="3" cellspacing="0">
<tr>
<th>&nbsp;</th><th colspan="2">Property</th>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="#sandboxType">sandboxType</a> : <a href="../String.html">String</a>
<div class="summaryTableDescription">[static][read-only]Indicates the type of security sandbox in which the calling SWF file is operating.</div>
</td>
</tr>
</table>
<a name="propertiesInheritedFromObject"></a>
<table class="summaryTable" cellpadding="3" cellspacing="0">
<tr>
<th>&nbsp;</th><th>Properties inherited from class <a href="../Object.html">Object</a></th>
</tr>
<tr>
<td class="summaryTablePaddingCol">&nbsp;</td><td class="inheritanceList"><code><a href="../Object.html#__proto__">__proto__</a>, <a href="../Object.html#__resolve">__resolve</a>, <a href="../Object.html#constructor">constructor</a>, <a href="../Object.html#prototype">prototype</a></code></td>
</tr>
</table>
</div>
<a name="methodSummary"></a>
<div class="summarySection">
<div class="summaryTableTitle">Public Methods</div>
<table id="summaryTableMethod" class="summaryTable " cellpadding="3" cellspacing="0">
<tr>
<th>&nbsp;</th><th colspan="2">Method</th>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#allowDomain()">allowDomain</a>(domain1:<a href="../String.html">String</a>):Void</div>
<div class="summaryTableDescription">[static]Lets SWF files and HTML files in the identified domains access objects and variables in the SWF file that contains the <code>allowDomain()</code> call.</div>
</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#allowInsecureDomain()">allowInsecureDomain</a>(domain:<a href="../String.html">String</a>):Void</div>
<div class="summaryTableDescription">[static]Lets SWF files and HTML files in the identified domains access objects and variables in the calling SWF file, which is hosted by means of the HTTPS protocol.</div>
</td>
</tr>
<tr class="">
<td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol">
<div class="summarySignature">
<a class="signatureLink" href="#loadPolicyFile()">loadPolicyFile</a>(url:<a href="../String.html">String</a>):Void</div>
<div class="summaryTableDescription">[static]Looks for a policy file at the location specified by the <code>url</code> parameter.</div>
</td>
</tr>
</table>
<a name="methodsInheritedFromObject"></a>
<table class="summaryTable" cellpadding="3" cellspacing="0">
<tr>
<th>&nbsp;</th><th>Methods inherited from class <a href="../Object.html">Object</a></th>
</tr>
<tr>
<td class="summaryTablePaddingCol">&nbsp;</td><td class="inheritanceList"><code><a href="../Object.html#addProperty()">addProperty</a>, <a href="../Object.html#hasOwnProperty()">hasOwnProperty</a>, <a href="../Object.html#isPropertyEnumerable()">isPropertyEnumerable</a>, <a href="../Object.html#isPrototypeOf()">isPrototypeOf</a>, <a href="../Object.html#registerClass()">registerClass</a>, <a href="../Object.html#toString()">toString</a>, <a href="../Object.html#unwatch()">unwatch</a>, <a href="../Object.html#valueOf()">valueOf</a>, <a href="../Object.html#watch()">watch</a></code></td>
</tr>
</table>
</div>
<script type="text/javascript" language="javascript">
<!--
showHideInherited();
--></script>
<div class="MainContent">
<a name="propertyDetail"></a>
<div class="detailSectionHeader">Property detail</div>
<a name="sandboxType"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">sandboxType</td><td class="detailHeaderType">property</td>
</tr>
</table>
<div class="detailBody">
<code>sandboxType:<a href="../String.html">String</a></code>&nbsp;&nbsp;[read-only]<p></p>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" style="white-space:nowrap"><b>Player version:&nbsp;</b></td><td>Flash Player 8 &mdash; See the description for version-specific details.</td>
</tr>
</table>
<p></p><p>Indicates the type of security sandbox in which the calling SWF file is operating.            </p><p><code>System.security.sandboxType</code> has one of the following values:</p>             <ul>       <li><code>remote</code>: This SWF file is from an Internet URL, and will operate under domain-based sandbox         rules.</li>       <li><code>localWithFile</code>: This SWF file is a local file, and has not been trusted by the user, and         was not published with a networking designation. This SWF file may read from local data sources, but may         not communicate with the Internet.</li>       <li><code>localWithNetwork</code>: This SWF file is a local file, and has not been trusted by the user, and         was published with a networking designation. This SWF may communicate with the Internet, but may not         read from local data sources.</li>       <li><code>localTrusted</code>: This SWF file is a local file, and has been trusted by the user, using either         the Settings Manager or a FlashPlayerTrust configuration file. This SWF file may both read from local data         sources and communicate with the Internet.</li>       </ul>            <p>Note that this property may be examined from a SWF file of any version, but is only supported in Flash       Player 8 or greater.  This unusual arrangement means that you can examine this property, for example,       from a version 7 SWF file playing in Flash Player 8.  This all-versions support means that, if you publish       for a version earlier than 8, you will not know at publish time whether this property will be       supported or not at playback time.  Thus, in a SWF file of version 7 or lower, you may find that this       property has an undefined value; that should only happen when the player version (indicated by       <code>System.capabilities.version</code>) is less than 8.  In that situation, you can determine the sandbox type       according to whether your SWF file's URL is a local file or not.  If so, you can assume Flash Player will       classify your SWF as <code>"localTrusted"</code> (prior to Flash Player 8, this was how all local content was       treated).  If not, you can assume Flash Player will classify your SWF file as <code>"remote".</code></p>            <p>For more information related to security, see the following: </p>            <ul>          <li>"Understanding Security" in <i>Learning ActionScript 2.0 in Flash</i></li>       <li>The Flash Player Developer Center Topic:       <a href="http://www.adobe.com/go/devnet_security_en" target="external">Security</a></li>       </ul>            <span class="label">Implementation</span>
<br>
<code>&nbsp;&nbsp;&nbsp;&nbsp;public static function get sandboxType():<a href="../String.html">String</a></code>
<br>
</div>
<a name="methodDetail"></a>
<div class="detailSectionHeader">Method detail</div>
<a name="allowDomain()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">allowDomain</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td>
</tr>
</table>
<div class="detailBody">
<code>public static function allowDomain(domain1:<a href="../String.html">String</a>):Void</code>
<p></p>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" style="white-space:nowrap"><b>Player version:&nbsp;</b></td><td>Flash Player 6 &mdash; Behavior changed in Flash Player 7; behavior changed in Flash Player 8.</td>
</tr>
</table>
<p></p><p>Lets SWF files and HTML files in the identified domains access objects and variables in the       SWF file that contains the <code>allowDomain()</code> call.             </p><p>If two SWF files are served from the same domain &#x2014; for example, http://mysite.com/movieA.swf and       http://mysite.com/movieB.swf &#x2014; then movieA.swf can examine and modify variables, objects, properties,       methods, and so on in movieB.swf, and movieB.swf can do the same for movieA.swf. This is called <i>cross-movie       scripting</i> or simply <i>cross-scripting</i>.</p>       <p>If two SWF files are served from different domains &#x2014; for example, http://mysite.com/movieA.swf and       http://othersite.com/movieB.swf &#x2014; then, by default, Flash Player does not allow movieA.swf to script       movieB.swf, nor movieB.swf to script movieA.swf. A SWF file gives SWF files from other domains       permission to script it by calling <code>System.security.allowDomain()</code>. This is       called <i>cross-domain scripting</i>. By calling <code>System.security.allowDomain("mysite.com")</code>, movieB.swf gives movieA.swf permission to script movieB.swf. </p>             <p>In any cross-domain situation, two parties are involved, and it's important to be clear about which       side is which. For the purposes of this discussion, the side performing the cross-scripting       is called the <i>accessing party</i> (usually the accessing SWF), and the other side is called <i>the party being accessed</i>        (usually the SWF being accessed). To continue the example, when movieA.swf scripts movieB.swf,       movieA.swf is the accessing party, and movieB.swf is the party being accessed.</p>             <p><img src="../images/crossScript_as2.jpg" alt="cross domain diagram" /></p>            <p>Cross-domain permissions that are established with <code>System.security.allowDomain()</code> are asymmetrical.       In the previous example, movieA.swf can script movieB.swf, but movieB.swf cannot script movieA.swf,       because movieA.swf has not called <code>System.security.allowDomain()</code> to give othersite.com permission       to script movieA.swf. You can set up symmetrical permissions by having both SWF files call       System.security.allowDomain().</p>            <p>In addition to protecting SWF files from cross-domain scripting originated by other SWF files, Flash Player       protects SWF files from cross-domain scripting originated by HTML files. HTML-to-SWF scripting can be       performed with older Flash browser functions such as <code>SetVariable</code> or callbacks       established by using <code>ExternalInterface.addCallback()</code>. When HTML-to-SWF scripting crosses       domain boundaries, the SWF file being accessed must call <code>System.security.allowDomain()</code>,       just as when the accessing party is a SWF file, or the operation will fail.</p>            <p>Specifying an IP address as a parameter to <code>System.security.allowDomain()</code>       does not permit access by all parties that originate at the specified IP address.       Instead, it permits access only by parties that were loaded by explicitly specifying       that IP address in their URLs, rather than by a domain name that maps to that IP address.</p>            <p><b>Version-specific differences</b><br />       Flash Player's cross-domain security rules have evolved from version to version.       The following table summarizes the differences.</p>        <table width="100%"  class="innertable">        <tr>          <th>Latest SWF version involved in the cross-scripting operation.</th>          <th>allowDomain() needed?</th>          <th>allowInsecureDomain() needed?</th>         <th>Which SWF must call allowDomain() or allowInsecureDomain()?</th>          <th>What can be specified in allowDomain() or allowInsecureDomain()?</th>       </tr>        <tr>          <td><div align="center">5 or earlier</div></td>          <td>No</td>          <td><div align="center">No</div></td>          <td><div align="center">N/A</div></td>          <td><div align="center">N/A</div></td>        </tr>        <tr>          <td><div align="center">6</div></td>          <td>Yes, if superdomains don't match</td>          <td><div align="center">No</div></td>          <td>The SWF file being accessed, or any SWF file with the same superdomain as the SWF file being accessed</td>          <td><ul>            <li>Text-based domain (mysite.com)</li>            <li>IP address (192.168.1.1)</li>          </ul></td>        </tr>        <tr>          <td><div align="center">7</div></td>          <td>Yes, if domains don't match exactly</td>          <td>Yes, if performing HTTP-to-HTTPS access (even if domains match exactly)</td>          <td>The SWF file being accessed, or any SWF file with exactly the same domain as the SWF file being accessed</td>          <td><ul>            <li>Text-based domain (mysite.com)</li>            <li>IP address (192.168.1.1)</li>          </ul></td>        </tr>        <tr>          <td><div align="center">8 or later</div></td>          <td>Yes, if domains don't match exactly</td>          <td>Yes, if performing HTTP-to-HTTPS access (even if domains match exactly)</td>          <td>SWF being accessed</td>          <td><ul>            <li>Text-based domain (mysite.com)</li>            <li>IP address (192.168.1.1)</li>            <li>Wildcard (*) </li>          </ul></td>       </tr>       </table>            <p>The versions that control the behavior of Flash Player are <i>SWF versions</i>       (the published version of a SWF file), not the version of Flash Player itself.       For example, when Flash Player 8 is playing a SWF file published for version 7, it        applies behavior that is consistent with version 7. This practice ensures that player upgrades do not       change the behavior of <code>System.security.allowDomain()</code> in deployed SWF files.</p>            <p>The version column in the previous table shows the latest SWF version involved in a cross-scripting       operation. Flash Player determines its behavior according to either the accessing SWF file's       version or the version of the SWF file that is being accessed, whichever is later.</p>            <p>The following paragraphs provide more detail about Flash Player security changes involving       <code>System.security.allowDomain()</code>.</p>       <p><b>Version 5</b>. No cross-domain scripting restrictions.</p>            <p><b>Version 6</b>. Cross-domain scripting security is introduced. By default, Flash Player forbids       cross-domain scripting; <code>System.security.allowDomain()</code> can permit it. To determine whether two files are       in the same domain, Flash Player uses each file's superdomain, which is the exact host name from the       file's URL, minus the first segment, down to a minimum of two segments. For example, the superdomain of       www.mysite.com is mysite.com. This example would permit SWF files from www.mysite.com and       store.mysite.com to script each other without calling <code>System.security.allowDomain()</code>.</p>            <p><b>Version 7</b>. Superdomain matching is changed to exact domain matching. Two files are       permitted to script each other only if the host names in their URLs are identical; otherwise, a call to       <code>System.security.allowDomain()</code> is required. By default, files loaded from non-HTTPS URLs are no longer       permitted to script files loaded from HTTPS URLs, even if the files are loaded from the exactly the same       domain. This restriction helps protect HTTPS files, because a non-HTTPS file is vulnerable to       modification during download, and a maliciously modified non-HTTPS file could corrupt an HTTPS file,       which is otherwise immune to such tampering. <code>System.security.allowInsecureDomain()</code> is introduced to       allow HTTPS SWF files that are being accessed to voluntarily disable this restriction, but Adobe       recommends against using <code>System.security.allowInsecureDomain()</code>.</p>            <p><b>Version 8</b>. Two major areas of change:</p>       <ul>       <li>Calling <code>System.security.allowDomain()</code> now permits cross-scripting operations       only if the SWF file being accessed is the SWF file that called <code>System.security.allowDomain()</code>.       In other words, a SWF file that calls <code>System.security.allowDomain()</code> now permits access only to itself.       In previous versions, calling <code>System.security.allowDomain()</code> permitted cross-scripting operations       where the SWF file being accessed could be any SWF file in the same domain as the SWF file that called       <code>System.security.allowDomain()</code>. Calling <code>System.security.allowDomain()</code> previously opened up       the entire domain of the calling SWF file.</li>             <li>Support has been added for wildcard values with <code>System.security.allowDomain("*")</code> and       <code>System.security.allowInsecureDomain("*")</code>.       The wildcard (*) value permits cross-scripting operations where the accessing file is any file at all,       loaded from anywhere. Think of the wildcard as a global permission. Wildcard permissions can       be useful in general, and in particular they are required to enable certain kinds of operations       under the new local file security rules in Flash Player 8. Specifically,       for a local SWF file with network-access permissions to script a SWF file on the       Internet, the Internet SWF file being accessed must call <code>System.security.allowDomain("*")</code>,       reflecting that the origin of a local SWF file is unknown. (If the Internet SWF file being accessed       is loaded from an HTTPS URL, the Internet SWF file must instead call       <code>System.security.allowInsecureDomain("*")</code>.)</li>       </ul>             <p>Occasionally, you may encounter the following situation: You load a child SWF file       from a different domain and want to allow the child SWF file to script the parent SWF file,       but you don't know the final domain from which the child SWF file will come. This can happen, for       example, when you use load-balancing redirects or third-party servers.</p>            <p>In this situation, you can use the <code>MovieClip._url</code> property as a parameter to this method.       For example, if you load a SWF file into the movie clip <code>my_mc</code>, you can call <code>System.security.allowDomain(my_mc._url)</code>.       If you do this, be sure to wait until the SWF file in <code>my_mc</code> begins loading, because the <code>_url</code> property       does not have its final, correct value until this time. The best way to determine when a child SWF file       has begun loading is to use <code>MovieClipLoader.onLoadStart</code>.</p>            <p>The opposite situation can also occur; that is, you might create a child SWF file       that wants to allow its parent to script it, but doesn't know what the domain of its       parent will be. In this situation, call <code>System.security.allowDomain(_parent._url)</code>        from the child SWF. You don't have to wait for the parent SWF file       to load; the parent will already be loaded by the time the child loads.</p>            <p>If you are publishing for Flash Player 8, you can also handle these situations by calling       <code>System.security.allowDomain("*")</code>. However, this can sometimes be a dangerous shortcut,       because it allows the calling SWF file to be accessed by any other SWF file from any domain.       It is usually safer to use the <code>_url</code> property.</p>            <p>For more information related to security, see the following: </p>            <ul>          <li>"Understanding Security" in <i>Learning ActionScript 2.0 in Flash</i></li>       <li>The Flash Player Developer Center Topic:       <a href="http://www.adobe.com/go/devnet_security_en" target="external">Security</a></li>       </ul>            <span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">domain1</span>:<a href="../String.html">String</a></code> &mdash; One or more strings that specify domains that can access objects and variables in       the SWF file that contains the <code>System.Security.allowDomain()</code> call. The domains can be       formatted in the following ways:            <ul>         <li><code>"domain.com"</code></li>         <li><code>"http://domain.com"</code></li>         <li><code>"http://IPaddress"</code></li>         <li>(Flash Player 8 only) <code>"*"</code> <br/>         You can pass a wildcard ("*") to <code>System.security.allowDomain()</code>         to allow all domains, including local hosts, access to the calling SWF file. Before using         the wildcard, be sure that you want to provide such broad access to the calling SWF file. See         the discussion in the main description of this method.</li>       </ul>            </td>
</tr>
</table>
<p>
<span class="label">See also</span>
</p>
<div class="seeAlso">
<a href="../flash/external/ExternalInterface.html#addCallback()" target="">ExternalInterface.addCallback()</a>
<br>
<a href="../MovieClipLoader.html#event:onLoadComplete" target="">MovieClipLoader.onLoadComplete</a>
<br>
<a href="../MovieClip.html#_parent" target="">MovieClip._parent</a>
<br>
<a href="../MovieClip.html#_url" target="">MovieClip._url</a>
<br>
<a href="security.html#allowInsecureDomain()" target="">System.security.allowInsecureDomain()</a>
</div>
<br>
<span class="label">Example</span>
<br>The SWF file located at www.adobe.com/MovieA.swf contains the following lines:             <div class='listing'><pre>
System.security.allowDomain("www.shockwave.com");
loadMovie("http://www.shockwave.com/MovieB.swf", my_mc);
</pre></div>             <p>Because MovieA contains the <code>allowDomain()</code> call, MovieB can access the objects       and variables in MovieA. If MovieA didn't contain this call, the Flash Player security implementation       would prevent MovieB from accessing MovieA's objects and variables.</p>            <p></p>
</div>
<a name="allowInsecureDomain()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">allowInsecureDomain</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public static function allowInsecureDomain(domain:<a href="../String.html">String</a>):Void</code>
<p></p>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" style="white-space:nowrap"><b>Player version:&nbsp;</b></td><td>Flash Player 7</td>
</tr>
</table>
<p></p><p>Lets SWF files and HTML files in the identified domains access objects and variables in the calling       SWF file, which is hosted by means of the HTTPS protocol. Adobe does not recommend using       this method; see "Security considerations," later in this entry.             </p><p>This method works in the same way as <code>System.security.allowDomain()</code>, but it also       permits operations in which the accessing party is loaded with a non-HTTPS protocol, and the       party being accessed is loaded with HTTPS. In Flash Player 7 and later,       non-HTTPS files are not allowed to script HTTPS files. The <code>allowInsecureDomain()</code> method lifts this       restriction when the HTTPS SWF file being accessed uses it.</p>             <p>Use <code>allowInsecureDomain()</code> only to enable scripting from non-HTTPS files       to HTTPS files. Use it to enable scripting when the accessing non-HTTPS file and       the HTTPS file being accessed are served from the same domain, for example, if a SWF file at       http://mysite.com wants to script a SWF file at https://mysite.com. Do not use this method to enable       scripting between non-HTTPS files, between HTTPS files, or from HTTPS files to non-HTTPS       files. For those situations, use <code>allowDomain()</code> instead.</p>             <p><b>Security considerations</b>:       Flash Player provides <code>allowInsecureDomain()</code> to maximize flexibility, but Adobe recommends       against calling this method. Serving a file over HTTPS provides several protections       for you and your users, and calling <code>allowInsecureDomain</code> weakens one of those       protections. The following scenario illustrates how <code>allowInsecureDomain()</code> can compromise security, if it is not used with       careful consideration.</p>             <p><b>Note</b>: The following information is only one possible scenario, designed to       help you understand <code>allowInsecureDomain()</code> through a real-world example       of cross-scripting.       It does not cover all issues with security architecture and should be used for background       information only. For more information related to security, see the following: </p>            <ul>          <li>"Understanding Security" in <i>Learning ActionScript 2.0 in Flash</i></li>       <li>The Flash Player Developer Center Topic:       <a href="http://www.adobe.com/go/devnet_security_en" target="external">Security</a></li>       </ul>            <p>Imagine that you are building an e-commerce site that consists of two components:       a catalog, which does not need to be secure, because it contains only public information;       and a shopping cart/checkout component, which must be secure to protect users' financial and       personal information. Suppose that you are considering serving the catalog from       http://mysite.com/catalog.swf and the cart from https://mysite.com/cart.swf. One       requirement for your site is that a third party should not be able to steal your       users' credit card numbers by taking advantage of a weakness in your security architecture.</p>             <p>Suppose that a middle-party attacker intervenes between your server and your users, attempting       to steal the credit card numbers that your users enter into your shopping cart application.       A middle party might, for example, be an unscrupulous ISP used by some of your users, or a       malicious administrator at a user's workplace &#x2014; anyone who has the ability to view or alter       network packets transmitted over the public Internet between your users and your servers.       This situation is not uncommon.</p>             <p>If cart.swf uses HTTPS to transmit credit card information to your servers, then the       middle-party attacker can't directly steal this information from network packets, because the       HTTPS transmission is encrypted. However, the attacker can use a different technique: altering the       contents of one of your SWF files as it is delivered to the user, replacing your SWF file with an       altered version that transmits the user's information to a different server, owned by the attacker.</p>             <p>The HTTPS protocol, among other things, prevents this "modification" attack from working,       because, in addition to being encrypted, HTTPS transmissions are tamper-resistant.       If a middle-party attacker alters a packet, the receiving side detects the alteration       and discards the packet. So the attacker in this situation can't alter cart.swf, because it       is delivered over HTTPS.</p>             <p>However, suppose that you want to allow buttons in catalog.swf, served over HTTP,       to add items to the shopping cart in cart.swf, served over HTTPS. To accomplish this,       cart.swf calls <code>allowInsecureDomain()</code>, which allows catalog.swf to script cart.swf.       This action has an unintended consequence: Now the hypothetical attacker can alter        catalog.swf as it is initially being downloaded by       the user, because catalog.swf is delivered with HTTP and is not tamper-resistant.       The attacker's altered catalog.swf can now script cart.swf, because cart.swf contains       a call to <code>allowInsecureDomain()</code>. The altered catalog.swf file can use ActionScript to access       the variables in cart.swf, thus reading the user's credit card information and other       sensitive data. The altered catalog.swf can then send this data to an attacker's server.       </p>             <p>Obviously, this implementation is not desired, but you still want to allow       cross-scripting between the two SWF files on your site. Here are two possible ways to redesign       this hypothetical e-commerce site to avoid <code>allowInsecureDomain()</code>:</p>             <ul>       <li>Serve all SWF files in the application over HTTPS. This is by far the simplest and most       reliable solution. In the scenario described, you would serve both catalog.swf and cart.swf        over HTTPS. You might experience slightly higher bandwidth consumption and server CPU load       when switching a file such as catalog.swf from HTTP to HTTPS, and your users might experience       slightly longer application load times. You need to experiment with real servers to       determine the severity of these effects; usually they are no worse than 10-20% each, and       sometimes they are not present at all. You can usually improve results by using HTTPS-accelerating       hardware or software on your servers. A major benefit of serving all       cooperating SWF files over HTTPS is that you can use an HTTPS URL as the main URL       in the user's browser without generating any mixed-content warnings from the browser.       Also, the browser's padlock icon becomes visible, providing your users with       a common and trusted indicator of security.</li>             <li>Use HTTPS-to-HTTP scripting, rather than HTTP-to-HTTPS scripting. In the scenario described, you       could store the contents of the user's shopping cart in catalog.swf, and have cart.swf manage       only the checkout process. At checkout time, cart.swf could retrieve the cart contents from       ActionScript variables in catalog.swf. The restriction on HTTP-to-HTTPS scripting is asymmetrical;       although an HTTP-delivered catalog.swf file cannot safely be allowed to script an HTTPS-delivered cart.swf file,       an HTTPS cart.swf file may script the HTTP catalog.swf file.       This approach is more delicate than the all-HTTPS approach; you must be careful not to trust any       SWF file delivered over HTTP, because of its vulnerability to tampering. For example, when cart.swf       retrieves the ActionScript variable that describes the cart contents, the ActionScript code       in cart.swf cannot trust that the value of this variable is in the format that you expect.       You must carefully validate that the cart contents do not contain invalid data that might       lead cart.swf to take an undesired action. You must also accept the risk that a middle party,       by altering catalog.swf, could supply valid but inaccurate data to cart.swf; for example, by placing       items in the user's cart. The usual checkout process mitigates       this risk somewhat by displaying the cart contents and total cost for final approval by the user,       but the risk remains present.</li>       </ul>             <p>Web browsers have enforced separation between HTTPS and non-HTTPS files for years,       and the scenario described illustrates one good reason for this restriction.       Flash Player gives you the ability to work around this security restriction when you       absolutely must, but be sure to consider the consequences carefully before doing so.</p>             <p>For more information related to security, see the following: </p>            <ul>          <li>"Understanding Security" in <i>Learning ActionScript 2.0 in Flash</i></li>       <li>The Flash Player Developer Center Topic:       <a href="http://www.adobe.com/go/devnet_security_en" target="external">Security</a></li>       </ul>            <span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">domain</span>:<a href="../String.html">String</a></code> &mdash; An exact domain name, such as www.myDomainName.com or       store.myDomainName.com. In Flash Player 8, you can pass a wildcard ("*") to       <code>System.security.allowInsecureDomain()</code> to allow all domains, including local       hosts, access to the calling SWF file. Do not use the wildcard unless you are certain that       you want to allow <i>all</i> domains, including local hosts, to access the HTTPS SWF file.            </td>
</tr>
</table>
<p>
<span class="label">See also</span>
</p>
<div class="seeAlso">
<a href="security.html#allowDomain()" target="">security.allowDomain()</a>
<br>
<a href="../System.html#exactSettings" target="">System.exactSettings</a>
</div>
<br>
<span class="label">Example</span>
<br>In the following example, you host a math test on a secure domain so that only registered       students can access it. You have also developed a number of SWF files that illustrate certain       concepts, which you host on an insecure domain. You want students to access the test from the SWF       file that contains information about a concept.             <div class='listing'><pre>
// This SWF file is at https://myEducationSite.somewhere.com/mathTest.swf
// Concept files are at http://myEducationSite.somewhere.com
System.security.allowInsecureDomain("myEducationSite.somewhere.com");
</pre></div>            <p></p>
</div>
<a name="loadPolicyFile()"></a>
<table cellspacing="0" cellpadding="0" class="detailHeader">
<tr>
<td class="detailHeaderName">loadPolicyFile</td><td class="detailHeaderParens">()</td><td class="detailHeaderType">method</td><td class="detailHeaderRule">&nbsp;</td>
</tr>
</table>
<div class="detailBody">
<code>public static function loadPolicyFile(url:<a href="../String.html">String</a>):Void</code>
<p></p>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top" style="white-space:nowrap"><b>Player version:&nbsp;</b></td><td>Flash Player 7.0.19.0</td>
</tr>
</table>
<p></p><p>Looks for a policy file at the location specified by the <code>url</code>       parameter. Adobe AIR and Flash Player use policy files to determine        whether to permit applications to load data from servers other than their own.       Note that even though the method name is <code>loadPolicyFile()</code>,       the file isn't actually loaded until a network request that requires a policy file is made.             </p><p>By default, Flash Player looks for a master policy file in a specific location on the       server to which a data-loading request is being made. With <code>Security.loadPolicyFile()</code>,       Flash Player can load policy files from arbitrary locations, as shown in the following example:</p>             <div class='listing'><pre>
Security.loadPolicyFile("http://www.example.com/sub/dir/pf.xml");
</pre></div>             <p>This statement causes Flash Player to attempt to retrieve a policy file from the specified URL. Any permissions       granted by the policy file at that location will apply to all content at the same level or lower in       the virtual directory hierarchy of the server. However, if the master policy file doesn't specify that the target location       can serve policy files, the call to <code>loadPolicyFile()</code> has no effect,       even if there is a policy file at that location. </p>            <p> Call <code>loadPolicyFile()</code> before attempting any network operations that require the policy file.       Flash Player automatically queues networking requests behind their corresponding policy file attempts.       So, for example, it is acceptable to call <code>loadPolicyFile()</code> immediately before initiating       a networking operation. </p>           <p>When checking for a master policy file, Flash Player waits three seconds for a server response.       If a response isn't received, Flash Player assumes that no master policy file exists.       However, there is no default timeout value for calls to <code>loadPolicyFile()</code>;       Flash Player assumes that the file being called exists, and waits as long as necessary to load it.       Therefore, if you want to make sure that a master policy file is loaded, use <code>loadPolicyFile()</code>       to call it explicitly.</p>            <p>The following code continues the previous example:</p>             <div class='listing'><pre>
<code>loadVariables("http://foo.com/sub/dir/vars.txt") // </code>allowed
loadVariables("http://foo.com/sub/dir/deep/vars2.txt") // allowed
loadVariables("http://foo.com/elsewhere/vars3.txt") <code>// not allowed</code>
</pre></div>             <p>You can use <code>loadPolicyFile()</code> to load any number of policy files. When considering a       request that requires a policy file, Flash Player always waits for the completion of any policy       file downloads before denying a request. As a final fallback, if no policy file specified with       <code>loadPolicyFile()</code> authorizes a request, Flash Player consults the original default       locations.</p>             <p>You cannot load URL policy files that are served from the following commonly reserved ports:</p>            <p>HTTP: 20  (ftp data), 21 (ftp control)</p>            <p>HTTP and FTP: 1 (tcpmux), 7 (echo), 9 (discard), 11 (systat), 13 (daytime), 15 (netstat), 17 (qotd), 19 (chargen), 22 (ssh),       23 (telnet), 25 (smtp), 37 (time), 42 (name), 43 (nicname), 53 (domain), 77 (priv-rjs), 79 (finger), 87 (ttylink), 95 (supdup),       101 (hostriame), 102 (iso-tsap), 103 (gppitnp), 104 (acr-nema), 109 (pop2), 110 (pop3), 111 (sunrpc), 113 (auth), 115 (sftp),       117 (uucp-path), 119 (nntp), 123 (ntp), 135 (loc-srv / epmap), 139 (netbios), 143 (imap2), 179 (bgp), 389 (ldap), 465 (smtp+ssl),       512 (print / exec), 513 (login), 514 (shell), 515 (printer), 526 (tempo), 530 (courier), 531 (chat), 532 (netnews), 540 (uucp),       556 (remotefs), 563 (nntp+ssl), 587 (smtp), 601 (syslog), 636 (ldap+ssl), 993 (ldap+ssl), 995 (pop3+ssl), 2049 (nfs),       4045 (lockd), 6000 (x11) </p>             <p>Using the <code>xmlsocket</code> protocol along with a specific port number lets you retrieve        policy files directly from an XMLSocket server, as shown in the following example. Socket        connections are not subject to the reserved port restriction described above.</p>             <div class='listing'><pre>
System.security.loadPolicyFile("xmlsocket://foo.com:414");
</pre></div>             <p>The <CODE>loadPolicyFile()</CODE> statement shown above causes Flash Player to attempt to retrieve a policy file       from the specified host and port.       Any port can be used, not only ports 1024 and higher. Upon establishing a connection with the       specified port, Flash Player transmits <code>&lt;policy-file-request /&gt;</code>, terminated by a       <code>null</code> byte. An XMLSocket server can be configured to serve both policy files and normal       XMLSocket connections over the same port, in which case the server should wait for       <code>&lt;policy-file-request /&gt;</code> before transmitting a policy file. A server can also be       set up to serve policy files over a separate port from standard connections, in which case it can       send a policy file as soon as a connection is established on the dedicated policy file port. The       server must send a null byte to terminate a policy file, and may thereafter close the connection;       if the server does not close the connection, Flash Player does so upon receiving the terminating       <code>null</code> byte.</p>             <p>A policy file served by an XMLSocket server has the same syntax as any other policy file, except       that it must also specify the ports to which access is granted. When a policy file comes from a       port lower than 1024, it can grant access to any ports; when a policy file comes from port 1024 or       higher, it can grant access only to other ports 1024 and higher. The allowed ports are specified in       a <code>"to-ports"</code> attribute in the <code>&lt;allow-access-from&gt;</code> tag. Single port       numbers, port ranges, and wildcards are all allowed. The following example shows an XMLSocket       policy file:</p>             <div class='listing'><pre>
&lt;cross-domain-policy&gt;
    &lt;allow-access-from domain="&#42;" to-ports="507" /&gt;
    &lt;allow-access-from domain="&#42;.foo.com" to-ports="507,516" /&gt;
    &lt;allow-access-from domain="&#42;.bar.com" to-ports="516-523" /&gt;
    &lt;allow-access-from domain="www.foo.com" to-ports="507,516-523" /&gt;
    &lt;allow-access-from domain="www.bar.com" to-ports="&#42;" /&gt;
&lt;/cross-domain-policy&gt;
</pre></div>             <p>Because the ability to connect to ports lower than 1024 is new, a socket policy file loaded with       <code>loadPolicyFile()</code> must always authorize this connection, even when a movie clip is connecting to       its own subdomain. </p>             <p>For more information related to security, see the following: </p>            <ul>          <li>"Understanding Security" in <i>Learning ActionScript 2.0 in Flash</i></li>       <li>The Flash Player Developer Center Topic:       <a href="http://www.adobe.com/go/devnet_security_en" target="external">Security</a></li>       </ul>            <span class="label">Parameters</span>
<table border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="20px"></td><td><code><span class="label">url</span>:<a href="../String.html">String</a></code> &mdash; A string; the URL where the cross-domain policy file to be loaded is located.            </td>
</tr>
</table>
</div>
<br>
<br>
<hr>
<br>
<p></p>
<center class="copyright"> &copy; 2004-2010 Adobe Systems Incorporated. All rights reserved. <br>Wed Apr 7 2010, 4:41 PM GMT-07:00 </center>
</div>
</body>
</html>
<!-- &copy; 2004-2010 Adobe Systems Incorporated. All rights reserved. Wed Apr 7 2010, 4:41 PM GMT-07:00 -->
